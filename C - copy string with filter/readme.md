Этот код выполняет **фильтрацию строки**, оставляя только **нелатинские символы** (то есть удаляет все буквы английского алфавита).  

### **Как это работает?**  
1. **Функция `filter_latin(const char c)`**  
   - Проверяет, является ли символ латинской буквой (`a-z`, `A-Z`).  
   - Возвращает:  
     - `0` (если символ латинский → его нужно **пропустить**),  
     - `1` (если символ нелатинский → его нужно **оставить**).  

2. **Функция `copy_string()`**  
   - Копирует символы из строки `src` в `dst`, применяя фильтр `filter`.  
   - Параметры:  
     - `dst` — буфер, куда копируется результат,  
     - `max_len_dst` — максимальная длина `dst` (с учётом `\0`),  
     - `src` — исходная строка,  
     - `filter` — указатель на функцию-фильтр.  
   - Копирование происходит **посимвольно**, с проверкой каждого символа фильтром.  
   - Если символ проходит фильтр (`filter()` вернул `1`), он копируется.  
   - Цикл останавливается, если:  
     - Закончилась исходная строка (`src[i] == '\0'`),  
     - Буфер `dst` заполнен (`j >= max_len_dst - 1`).  

3. **Функция `main()`**  
   - Считывает строку с клавиатуры (`fgets`), обрезает символ `\n`.  
   - Вызывает `copy_string()`, передавая:  
     - Целевую строку `str2` (размер `20`),  
     - Исходную строку `str`,  
     - Функцию-фильтр `filter_latin`.  
   - Выводит результат (`puts(str2)`).  

### **Пример работы**  
**Ввод:**  
```
Hello, мир! 123
```  
**Вывод:**  
```
, мир! 123
```  
(Удалены `H`, `e`, `l`, `l`, `o`).  

### **Особенности**  
- Если строка слишком длинная, она обрежется по размеру `str2` (19 символов + `\0`).  
- Фильтр можно заменить на любой другой (например, оставлять только цифры).  

Этот код полезен для обработки текста, например, при:  
- Удалении английских слов из строки,  
- Очистке данных от латинских символов,  
- Построении простых парсеров.